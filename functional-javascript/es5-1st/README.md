# 22/03/30 발표자료

# 0. 함수형 프로그래밍

## 0.1. 프로그래밍 패러다임

- 명령형 프로그래밍
    - 무엇(What)을 할 것인지 나타내기 보다, 어떻게(How) 할 건지 설명하는 방식
    1. 절차지향 프로그래밍 - 수행되어야 할 순차적인 처리 과정을 포함하는 방식
    2. 객체지향 프로그래밍 - 객체들의 집합으로 프로그램의 상호작용을 표현
- 선언형 프로그래밍
    - 무엇(What)을 할 건지 설명하는 방식
    - 함수형 프로그래밍 - 순수 함수를 조합하고 소프트웨어를 만드는 방식
    
- 함수형 프로그래밍은 거의 모든 것을 순수 함수로 나누어 문제를 해결하는 기법으로, 작은 문제를 해결하기 위한 함수를 작성하여 가독성을 높이고 유지보수를 용이하게 해준다.
- 클린 코드의 저자 Robert C. Martin은 함수형 프로그래밍을 대입문이 없는 프로그래밍이라 정의했다.
    
    ```jsx
    let a = [1, 2, 3, 4, 5];
    
    // 명령형 프로그래밍의 예시
    for (let i = 0; i < a.length; i++) {
      console.log(a[i],i);
    } // i에 값을 대입한다
    
    // 함수형 프로그래밍의 예시
    a.forEach((v, i) => console.log(v, i)); 
    // 1. 대입문을 사용하지 않는다.
    // 2. 작은 문제를 해결하기 위한 함수를 작성한다
    // -> 무엇을(What)에 포커스를 두고 출력을 하는 함수를 파라미터로 넘겼다.
    ```
    

## 0.2 함수형 프로그래밍이란?

### 0.2.1. 함수형 프로그래밍의 정의

> 함수형 프로그래밍은 부수효과가 없는 순수 함수를 1급 객체로 간주하여 파라미터로 넘기거나 반환값으로 사용할 수 있으며, 참조 투명성을 지킬 수 있다.
> 

- 여기서 부수효과(Side Effect)란 다음과 같은 변화 또는 변화가 발생하는 작업을 의미한다
    - 변수의 값이 변경됨
    - 자료구조를 제자리에서 수정함
    - 객체의 필드값을 설정함
    - 예외나 오류가 발생하며 실행이 중단됨
    - 콘솔 또는 파일 I/O가 발생함
    
- 이런 부수 효과(Side Effect)들을 제거한 함수들을 순수 함수(Pure Function)이라 부르며, 함수형 프로그래밍에서 사용하는 함수는 이런 순수 함수들이다.
    - Memory or I/O의 관점에서 Side Effect가 없는 함수
    - 함수의 실행이 외부에 영향을 끼치지 않는 함수
    
- 순수 함수(Pure Function)을 이용하면 얻을 수 있는 효과는 다음과 같다.
    - 함수 자체가 독립적이며 Side-Effect가 없기 때문에 Thread에 안전성을 보장받을 수 있다.
    - 즉 언제 실행 됐는지 평가 시점이 중요하지 않고 항상 같은 값을 리턴시켜 안전하고 다루기 쉽다.
    - Thread에 안정성을 보장받아 병렬 처리를 동기화 없이 진행할 수 있다.
    - 순수함수아 아닌 함수보다 강력한 조합성을 갖는다.
    
- 일급 객체란 다음과 같은 것들이 가능한 객체를 의미한다
    - 변수나 데이터 구조 안에 담을 수 있다.
    - 파라미터로 전달 할 수 있고, 인자(argument)로 전달 받을 수 있다.
    - 반환값으로 사용할 수 있다.
    - 할당에 사용된 이름과 무관하게 고유한 구별이 가능하다.
    
- 함수형 프로그래밍에서 함수는  일급 객체로 취급받기 때문에  함수를 파라미터로 넘기는 등의 작업이 가능하며, 자바스크립트도 마찬가지다.
- 자바스크립트에서 함수는 일급 함수이면서 일급 객체이고, 1급 객체이기 때문에 다른 일반적인 객체들에 적용 가능한 연산을 모두 지원한다. 그런 이유로 고차함수를 만들 수 있고, 콜백을 사용할 수 있다.

- 참조 투명성(Referential Transparency)란 다음과 같다.
    - 동일한 인자에 대해 항상 동일한 결과를 반환해야 한다
    - 참조 투명성을 통해 기존의 값을 변경되지 않고 유지된다(Immutable Data)
    
- 참조 투명성을 지키기 위해 부수효과가 없는 순수 함수를 사용하는 것이 아니라, 부수효과가 없는 순수 함수를 사용하기 때문에 참조 투명성을 지킬수 있다.
    
    
    ### 0.2.2. 함수형 프로그래밍 추가 설명
    
- 명령형 프로그래밍과 함수형 프로그래밍에서 사용하는 함수는 부수효과의 유/무에 따라 차이가 있다. 그에 따라 함수가 참조에 투명한지 안한지 나뉘어 지는데, 참조에 투명하다는 것은 말 그대로 함수를 실행하여도 어떠한 상태의 변화 없이 항상 동일한 결과를 반환하여 항상 동일하게(투명하게) 실행 결과를 참조(예측)할 수 있다는 것을 의미한다.
- 즉 어떤 함수 f에 어떠한 인자 x를 넣고 실행하게 되면, f는 입력된 인자에만 의존하므로 항상 f(x)라는 동일한 결과를 얻는다는 것을 의미한다. 부작용을 제거하여 프로그램의 동작을 이해하고 예측을 용이하게 하는 것은 함수형 프로그래밍으로 개발하려는 핵심 동기 중 하나이다.
- 이런 부분은 병령 처리 환경에서 개발할 때, 경쟁 상태(Race Condition)에 대한 비용을 줄여준다. 함수형 프로그래밍에서는 값의 대입 없이 항상 동일한 실행에 대해 동일한 결과를 반환하기 때문이다.

- 정리하자면 함수형 프로그래밍은 순수 함수를 통해 부수효과를 지양하고, 조합성을 강조하여 모듈화 수준을 높이는 프로그래밍 패러다임이다.

- 함수형 프로그래밍은 애플리케이션, 함수의 구성요소, 더 나아가서 언어 자체를 함수처럼 여기도록 만들고, 이러한 함수 개념을 가장 우선순위에 놓는다.
- 함수형 사고방식은 문제의 해결 방법을 동사(함수)들로 구성(조합)하는 것 - 마이클 포커스

```jsx
// 단순히 객체가 먼저 나오면 객체 지향 함수가 먼저 나오면 함수 지향 프로그래밍이다

person.moveLeft();
person.moveRight();
man.moveLeft();
man.moveRight();
// -> 객체지향에서는 데이터를 먼저 디자인하고 그 데이터에 맞는 메서드를 만든다

moveLeft(person);
moveRight(person);
moveLeft(man);
moveRight({ x: 5, y: 2 });
// -> 함수를 먼저 만들고, 그 함수에 맞게 데이터 세트를 구성한다
```

## 0. 예시

1. 
    
    ```jsx
    const add = (a, b) => {
    	return a+b;
    }
    // 동일한 인자에 항상 동일한 결과가 나오고 부수효과가 없으므로 순수함수이다.
    ```
    
2. 
    
    ```jsx
    let c = 10;
    const add = (a, b) => {
      return a + b + c;
    }
    // c값이 변하면 a, b 인자가 같더라도 결과 값이 달라질 수 있다.
    // 다만 c 값이 상수 값으로 고저오대 있다면 이 함수도 순수함수이다.
    ```
    
3. 
    
    ```jsx
    const add = (a, b) => {
      c = b;
      return a + b;
    }
    // 동일한 인자에 항상 동일한 결과가 나오지만,
    // 함수 실행 전후고 외부 상태인 c 값이 달라지므로 순수함수가 아니다.
    ```
    
4. 
    
    ```jsx
    let obj = { val: 10 };
    const add = (obj, b) => {
      obj.val += b;
    }
    
    // 인자로 들어온 값의 상태를 직접 변경하고, 새로운 값을 리턴하지도 않는다.
    // 함수형 프로그래밍에서는 원본 값을 두고 새로운 값을 만들어 원하는 부분에 새로운 값을 대치시킴으로 변경한다.
    // 이를 불변성 유지라고 한다.
    
    // not functional
    let arr1 = [1, 2, 3]
    arr1.push(4);
    
    // functional
    let arr2 = [1, 2, 3]
    arr2 = arr2.concat(4);
    ```
    
5. 
    
    ```jsx
    const addMaker = (a) => {
      return function(b) { // 클로저
        return a + b; 
      }
    };
    // 함수 내부에서만 a를 사용하며, a 값을 변경시키지 않는다. 참조만 할뿐 변경을 하지 않기 때문에 이 함수는 항상 동일한 값을 가리키고 있는 a와 함께 b를 더하는 순수 함수가 된다.
    
    const add10 = addMaker(10);
    console.log(add10(20)); // add10은 언제 평가해도 항상 동일한 값을 리턴시킨다
    ```
    
    > 클로저는 **함수와 그 함수가 선언된 렉시컬 환경과의 조합**이다.   
    A closure is the combination of a function and the lexical environment within which that function was declared.
    > 
    
    <aside>
    💡 자바스크립트 엔진은 함수를 어디서 호출했는지가 아니라 **함수를 어디에 정의했는지에 따라 상위 스코프를 결정**한다. 이를 렉시컬 스코프(정적 스코프)라 한다.
    
    </aside>
    
6. 
    
    ```jsx
    const f4 = (f1, f2, f3) => {
      return f3(f1() + f2());
    }
    
    const result1 = f4(
      () => 2,
      () => 1,
      n => n*n
    );
    console.log(result1) // 9
    ```
    
    - 함수형 프로그래밍 패러다임은 위와 같은 형태를 띄게 된다.
    - 원하는 인자를 받아둔 함수에 함수를 인자로 받아서, 받은 함수의 로직을 원하는 시점에 평가하는 것이다.
        
        (함수가 함수를 인자로 받아서, 그 함수의 로직대로 원하는 시점에 평가하고, 원하는 인자를 받아둔 함수에게 적용하면서 로직을 완성해 나가는 것)
        
    - 비동기나 동시성이 일어나는 병렬 처리를 동기화 없이 처리할 수 있다.
    
- 함수형 프로그래밍이 앞으로 각광 받을 이유
    - 좋아지는 하드웨어 성능
    - 좋아지는 컴파일러
    - 좋아지는 분산 / 리액티브 환경
    - 동시성 + 병렬성 관련 기술
    - 함수형 프로그래밍 기술

1. `filter` 함수는 인자로 `list`와 `predicate` 함수를 받는다. 
2. 루프를 돌며 `list`의 i번째 값을 `predicate`에 넘겨준다.
3. `predicate` 함수는 `list.length` 만큼 실행되며, 결과가 참일 때만 `new_list.push` 를 실행한다.
    - `new_list.push`가 실행될지 여부를 `predicate` 함수에 완전히 위임했다.
    - `_filter` 함수는 `predicate` 함수 내부에서 어떤 일을 하는지 모른다.
    - 오직 `predicate` 함수의 결과에만 의존한다.
4. 마지막에 `new_list를` 리턴한다.