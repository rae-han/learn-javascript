function add1(a, b) {
  return a+b;
}
/**
 * # add1 함수는 순수 함수
 * - 항상 동일한 인자에 동일한 결과가 나온다
 * - 부수효과가 없다
 */

let c = 10;
const add2 = (a, b) => {
  return a + b + c;
}
/**
 * - add2 함수는 c값이 변하면 a, b 인자가 같더라도 결과 값이 달라질 수 있다
 * - 다만 c 값이 상수 값으로 고정돼 있다면 add2 함수도 순수함수이다
 */
const add3 = (a, b) => {
  c = b;
  return a + b;
}
/**
 * - return 값으로 소통하는 것 외에 외부 상태에 영향을 미친다면 부수효과가 있고 순수함수가 아니게 된다.
 * - 함수 실행 전후로 c의 상태가 달라진다.
 */

let obj1 = { val: 10 };
const add4 = (obj, b) => {
  obj1.val += b;
}
/**
 * - 이 함수는 순수 함수가 아니다
 * - 리턴 값도 없다
 * - 인자로 들어온 값의 상태를 직접 변경하는 함수이다
 * ! 이렇게 코딩하는 것이 문제라는 것이 아니라 이 함수는 순수 함수가 아닐 뿐이다
 * * 함수형 프로그래밍에서는 객체의 값을 원래 있던 값은 두고 새로운 값을 만들어서 원하는 부분에 새로운 값을 대치시킴으로 변경한다.
 */

const add5 = (obj, b) => {
  return ({
    val: obj.val + b
  })
}
let obj2 = add5(obj1, 20);
/**
 * * 함수형 프로그래밍에서는 값을 변형해나가거나 값을 다룰때
 * * 원래 초기 값에 변화를 주지 않으면서, 모든 값들에 변화를 일이키지 않고
 * * 외부의 상태를 변화시키지 않으면서
 * * 인자로 받은 값을 직접 변화시키지 않으면서 프로그램을 만들어나가는 프로그래밍이다.
 */

/**
 * * 순수 함수는 평가 시점이 중요하지 않다
 * * 언제 실행 됐냐가 중요하지 않고 항상 같은 값을 리턴시킨다.
 * - 순수 함수가 아닌 함수보다 강력한 조합성을 갖는다 
 * - 안전하고 다루기 쉬운 함수가 된다
 */


